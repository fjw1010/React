/**
 * 배열 : push(추가), pop(빼기), map()
 *  push(배열 속성에 추가하는 방법)
 */
const fruits = ["Apple", "Banana"];
console.log(fruits); // 사과, 바나나만 출력됨!

fruits.push("Orange"); // push로 배열에 오렌지를 추가
console.log(fruits); // 추가된 오렌지까지 출력됨!
["사과", "바나나", "오렌지"];
/**
 *  pop(배열의 담긴 속성을 빼는 방법, 마지막 요소가 제거됨!)
 *      const fruits = ["사과", "바나나", "오렌지"];
 *      튀어나올 값을 담을 변수 생성
 *      const lastFruti = fruits.pop();
 *
 *      console.log(lastFruti);
 *      >> 출력 값은 마지막 요소인 오렌지만 삭제 됨!
 */
const lastFruti = fruits.pop();
console.log(lastFruti);
/**
 *  map(원본 배열에서 가공을 거쳐 새로운 배열을 리턴(반환) 하는 것이 map!!)
 *      1) 배열 내의 모든 요소 각각에 대해
 *      2) 주어진 함수를 호출한 결과를 모아 (콜백함수)
 *      3) 새로운 배열을 반환함!
 *      4) map은 원본 배열의 개수(요소의 개수)만큼 하나하나 체크
 *      5) map은 여러 개의 데이터 타입도 반환 가능
 */
const numbers = [1, 2, 3, 4, 5];
const squares = numbers.map(function (num) {
  return num * num; // 여기서 만약 리턴이 없다면 undefined 5개 출력
});
console.log(squares);

/**
 *  filter
 */
const numbers1 = [1, 2, 3, 4, 5];
const event = numbers1.filter(function (num) {
  return num % 2 === 0;
});

console.log(event);
// 2의 나머지 값만 나오게 됨! [2, 4]
// num의 2인 것만 return 해 달라고 하였으니까

/**
 *  filter
    실용적인 예시
    만약에 배열에 담긴 객체의 제목 동영상 02를 접근하여,
    그 값만 나오게 하고 싶을 때 아래와 같이 코드를 사용하면 됨!

    같은 제목의 다른 이미지를 갖고 오고 싶다면,
    새로운 객체 하나 생성하고, 객체의 제목을 똑같게 해 준 상태면
    각각 다른 이미지의 썸네일이미지가 표시될 것.
 */
const 동영상리스트 = [
  {
    아이디: 1,
    제목: "동영상01",
    썸네일이미지: "image01.jpg",
  },
  {
    아이디: 2,
    제목: "동영상02",
    썸네일이미지: "image02.jpg",
  },
  {
    아이디: 3,
    제목: "동영상03",
    썸네일이미지: "image03.jpg",
  },
];
const 필터링된동영상리스트 = 동영상리스트.filter(function (영상) {
  return 영상.제목 === "동영상02";
});

/**
 * 근데... filter를 사용해 보니 마치 if문과 비슷함
    그럼 if문을 쓰지 않고, filter를 사용하는 이유는?
    *
        1) 가독성 향상
            filter()는 배열의 요소를 필터링하는 과정을 더 직관적으로 표현할 수 있음
            if문을 사용하면 조건 검사와 배열 조작이 섞여있어 가독성이 더 떨어질 수 있음
            filter()를 사용하면 조건 검사와 배열 조작이 분리되어 코드가 더 깔끔해짐
        2) 재사용성 향상
            filter() 함수는 재사용이 용이하다!
            특정 조건으로 배열을 필터링하는 로직을 함수로 만들어 두면 필요할 때마다 재사용할 수 있기 때문
            filter()를 사용하면 조건 검사와 배열 조작이 분리되어 코드가 더 깔끔해짐
        3) 병렬 처리 기능
            filter() 함수는 배열의 각 요소를 병렬로 처리할 수 있음
            이를 통해 성능 향상을 기대할 수 있음
            if문은 순차적으로 처리되므로 병렬 처리가 어려움
        4) 가독성과 유지보수성 향상
            filter() 함수는 배열 조작 로직을 캡슐화하여 코드의 가독성과 유지보수성을 높일 수 있음
            if문을 사용하면 조건 검사와 배열 조작이 섞여 있어 코드 이해가 어려울 수 있음
        
        >> 상황에 따라 적절히 사용하는 것이 중요!
        하지만, 배열 조작이 필요한 경우에는 filter() 함수를 사용하는 것이 코드 품질 향상에 도움이 될 수 있음!!!
    *
 */
/**
 * reduce : 누적기
 */
const numbers2 = [1, 2, 3, 4, 5];
numbers.numbers2.reduce(function (누적된값, 일반값) {
  console.log(누적된값); // 처음 값인 1
  console.log(일반값); // 2, 3, 4, 5

  return 누적된값 + 일반값;
});
/**
 * 배열을 읽을 때는 0부터 읽음 0 === 배열의 첫번 째 요소와 같음
 * 그래서 누적된값 + 일반값을 더 했을 때,
 * 처음 요소에는 1
 * 그 다음 요소에는 누적된 값에 1이 있고 +를 해야하니까 1+2 = 3
 * 그 다음 요소에는 누적된 값에 3이 있고 +를 해야하니까 3+3 = 6
 * 그 다음 요소에는 누적된 값에 6이 있고 +를 해야하니까 6+4 = 10
 * 그 다음 요소에는 누적된 값이 10이 있고 +를 해야하니까 10+5 = 15
 *
 * 결론은 전부 다 더하면 15가 됨!
 */

/**
 * sort : 정렬을 위한
 */
const korean = ["다", "가", "나"];
console.log(korean);
// 배열의 순서가 뒤죽박죽일 때,
// 아래와 같이 sort()를 준 다음 console.log(korean)를 하게 되면,
// 가, 나, 다 순으로 정렬해 줌! sort()는 정렬 해 준다는 걸 까먹지 않기
korean.sort();
console.log(korean); // 값 > ['가', '나', '다'];

/**
 * 위에서는 sort()< 안에 아무런 인자도 넣지 않았지만 순서대로 출력이 됐음!
 * 이유는 유니코드에 따라서 정렬하였기 때문에
 * sort(비교함수 필요함) 유니코드가 읽었을 때 데이터 타입을 기반으로 비교하기 때문에
 *
 * 그래서 숫자를 이용했을 때, 어떻게 순서대로 나열하냐면
 * 오름차순, 내림차순 순으로 정렬이 가능함!
 * 아래에 a - b를 return 한다고 하였으니,
 * 결과 값은 [1, 3, 4, 50, 60, 70, 80, 300] 이렇게 나올 것
 *
 * 반대로 큰 값부터 하고 싶다면 내림차순 이용
 * return b - a을 하게 되면
 * 결과 값은 [300, 80, 70, 60, 50, 4, 3, 1]
 *
 * sort 비교함수를 이용할 때, 결과 값이 예측이 안 된다면
 * 파라미터 값(a, b)를 각각
 * console.log(a);
 * console.log(b);
 * 를 찍어서 어떻게 할당되고 비교하는지를 비교 해 보는 것도 정말 좋음 !
 * 버블 정렬과 비슷하기에 이렇게 비교해서 본다면 차이점을 알기 쉬울 것!!!
 */
const num = [300, 80, 50, 60, 70, 1, 4, 3];
num.sort(function (a, b) {
  return a - b;
});
console.log(num);
